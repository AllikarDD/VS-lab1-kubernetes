# Job (Задание) в Kubernetes

Офицальная документация *Job*:  [https://kubernetes.io/docs/concepts/workloads/controllers/job/](https://kubernetes.io/docs/concepts/workloads/controllers/job/)

---

#### **1. Что такое Job?**

**Job** — это контроллер Kubernetes для выполнения **одноразовых задач**, которые должны завершиться успешно. Основные сценарии использования:

* **Пакетная обработка данных** (ETL-процессы, генерация отчетов)
* **Одноразовые вычисления** (массовые рассылки, тестовые запуски)
* **Задачи с гарантированным завершением** (а не бесконечные сервисы)

**Ключевая особенность**:  
Job создает Pod'ы и гарантирует их успешное завершение (в отличие от Deployment/ReplicaSet, которые поддерживают постоянно работающие приложения).

---

#### **2. Пример простой Job**

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: pi-calculation
spec:
  template:
    spec:
      containers:
      - name: pi
        image: perl:5.34
        command: ["perl", "-Mbignum=bpi", "-wle", "print bpi(2000)"]  # Вычисление числа π
      restartPolicy: Never  # Или OnFailure
  backoffLimit: 4  # Максимальное количество повторных попыток
```

**Как это работает**:

1. Создается Pod, который вычисляет 2000 знаков числа π
2. После завершения расчета Job помечается как выполненная
3. Pod остается доступным для просмотра логов (но не перезапускается)

---

#### **3. Основные параметры Job**

|Параметр|Описание|
| ------------------| -----------------------------------------------------------------------------------------------------------------------------|
|**completions**|Количество успешных выполнений Pod'ов (по умолчанию 1)|
|**parallelism**|Сколько Pod'ов могут работать одновременно|
|**backoffLimit**|Максимальное количество повторных попыток при сбое (по умолчанию 6)|
|**activeDeadlineSeconds**|Максимальное время выполнения Job (в секундах)|
|**ttlSecondsAfterFinished**|Автоматическое удаление Job после завершения (Kubernetes 1.21+)|

---

#### **4. Типы Job**

1. **Одиночная задача** (1 Pod, 1 выполнение):

    ```yaml
    spec:
      completions: 1
      parallelism: 1
    ```
2. **Параллельная обработка с фиксированным количеством завершений**:

    ```yaml
    spec:
      completions: 10  # Всего 10 успешных выполнений
      parallelism: 2   # Одновременно работают 2 Pod'а
    ```
3. **Работа с очередями (Work Queue)** :

    ```yaml
    spec:
      completions: 1
      parallelism: 5   # 5 воркеров обрабатывают очередь
    ```

---

#### **5. Команды для управления**

|Действие|Команда|
| -----------------------------------------------| ----------------|
|Создать Job|​`kubectl apply -f job.yaml`​|
|Просмотреть активные Job|​`kubectl get jobs`​|
|Проверить статус|​`kubectl describe job/my-job`​|
|Просмотреть логи Pod'а|​`kubectl logs job/my-job`​|
|Удалить Job|​`kubectl delete job/my-job`​|
|Принудительно завершить|​`kubectl patch job/my-job -p '{"spec":{"activeDeadlineSeconds":5}}'`​|

---

#### **6. Обработка сбоев**

* **restartPolicy**:

  * ​`Never`​: Pod не перезапускается (создается новый)
  * ​`OnFailure`​: Pod перезапускается на том же узле
* **backoffLimit** ограничивает количество попыток (после чего Job помечается как failed)

**Пример обработки ошибок**:

```yaml
spec:
  backoffLimit: 3
  template:
    spec:
      restartPolicy: OnFailure
```

---

#### **7. Отличия от других контроллеров**

|Критерий|Job|Deployment|CronJob|
| ------------------| ----------------------------------------------------------------| -----------------------------------------------| --------------------------------------------------|
|**Цель**|Одноразовые задачи|Непрерывные сервисы|Периодические задачи|
|**Завершение**|Останавливается после выполнения|Работает постоянно|Запускается по расписанию|
|**Повтор**|Только при ошибках|Автоматические рестарты|По расписанию|

---

#### **8. Best Practices**

1. **Используйте** **​`Never`​**​ **для идемпотентных задач**, `OnFailure`​ — для устойчивых к рестартам.
2. **Ограничивайте ресурсы** (CPU/memory) в контейнерах.
3. **Настраивайте** **​`activeDeadlineSeconds`​**​ для предотвращения "зависших" задач.
4. **Для очистки** используйте `ttlSecondsAfterFinished`​ или ручное удаление.
5. **Логируйте результаты** в PersistentVolume или внешние системы.

---

#### **9. Ограничения**

* **Нет встроенного механизма очередей** (для сложных сценариев используйте системы вроде RabbitMQ + Worker Pod'ы)
* **Ограниченный мониторинг прогресса** (только общий статус Job)
* **Pod'ы не удаляются автоматически** после завершения (требуется настройка TTL)

---
